{"version":3,"file":"injection_token.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/di/injection_token.ts"],"names":[],"mappings":";;;;;AACA;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH;IACA;;OAEG;IACH,qBAAsB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;IAAG,CAAC;IACvC;;OAEG;IACH,8BAAQ,GAAR,cAAqB,MAAM,CAAC,WAAS,IAAI,CAAC,KAAO,CAAC,CAAC,CAAC;IACpD,kBAAC;AAAD,CAAC,AATD,IASC;AAED;IACA,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC;AAC5B,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH;IAAuC,kCAAW;IAElD;;OAEG;IACH,wBAAY,IAAY;QAAI,kBAAM,IAAI,CAAC,CAAC;IAAC,CAAC;IAC1C;;OAEG;IACH,iCAAQ,GAAR,cAAqB,MAAM,CAAC,oBAAkB,IAAI,CAAC,KAAO,CAAC,CAAC,CAAC;IAC7D,qBAAC;AAAD,CAAC,AAVD,CAAuC,WAAW,GAUjD;AAED;IACA,gBAAgB;IAChB,cAAc,CAAC,SAAS,CAAC,4CAA4C,CAAC;AACtE,CAAC","sourcesContent":["\n/**\n * Creates a token that can be used in a DI Provider.\n * \n * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))\n * \n * ```typescript\n * var t = new OpaqueToken(\"value\");\n * \n * var injector = Injector.resolveAndCreate([\n *   {provide: t, useValue: \"bindingValue\"}\n * ]);\n * \n * expect(injector.get(t)).toEqual(\"bindingValue\");\n * ```\n * \n * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions\n * caused by multiple providers using the same string as two different tokens.\n * \n * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better\n * error messages.\n * @deprecated since v4.0.0 because it does not support type information, use `InjectionToken<?>`\n * instead.\n */\nexport class OpaqueToken {\n/**\n * @param {?} _desc\n */\nconstructor(protected _desc: string) {}\n/**\n * @return {?}\n */\ntoString(): string { return `Token ${this._desc}`; }\n}\n\nfunction OpaqueToken_tsickle_Closure_declarations() {\n/** @type {?} */\nOpaqueToken.prototype._desc;\n}\n\n/**\n * Creates a token that can be used in a DI Provider.\n * \n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n * \n * `InjectionToken` is parametrize on `T` which is the type of object which will be returned by the\n * `Injector`. This provides additional level of type safety.\n * \n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n * \n * ### Example\n * \n * {\\@example core/di/ts/injector_spec.ts region='Injector'}\n * \n * \\@stable\n */\nexport class InjectionToken<T> extends OpaqueToken {\nprivate _differentiate_from_OpaqueToken_structurally: any;\n/**\n * @param {?} desc\n */\nconstructor(desc: string) { super(desc); }\n/**\n * @return {?}\n */\ntoString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nfunction InjectionToken_tsickle_Closure_declarations() {\n/** @type {?} */\nInjectionToken.prototype._differentiate_from_OpaqueToken_structurally;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}